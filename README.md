# puppy

监控分支，计划需求：

1. `conflict`: 不同功能分支之间，如果有冲突可以预警
2. `rot`: 检查太久没有 rebase master 的分支
3. `track`: 某个文件只要一改就报警（通告）

-----

## 使用

将 `config-demo.sh` 拷贝为 `config.sh` 文件，修改内容

其中 `WATCH_BRANCH` 指需要监控冲突的开发分支（一般以 `人名/` 或者 `feature/` 开头）  
如果有符合条件但需要忽略的分支，可以写在 `list-ignore.txt` 文件，一行一个分支名

如果有需要监控的文件或目录（功能 3），可以把路径写在 `list-track.txt`

运行 `./run.sh`，仓库会被放在 `repo` 目录

## Hooks

通过钩子可以将检测结果用别的手段（如邮件、即时通讯等）发出

跟 git 本身类似，在 `hooks` 目录，去掉 `.sample` 后缀即是钩子文件名，如果有且可执行（`chmod +x`）就会运行

1. `conflict`: 接收标准输入，头两行为分支名，之后为冲突的文件名
2. `rot`: 接受两个参数，第一为分支名，第二个为最后时间戳
3. `track`: 接受标准输入，每行一个文件名

## 关于分支冲突的细节

这个判定比较复杂。本意是，两个人都从 `master` 切了新分支并开发，但不可能做什么都会一直沟通，有可能两个人会改了相同的文件而并不知情，这个提醒可以让两人酌情沟通，避免更大面积的文件冲突。

但实际上开发代码千变万化，凭程序很难跑出准确的分析，这里用相对罗嗦的方法避免误报，但也不能完全避免，流程如下：

1. 记录各分支跟 `master` 的差异（基于 `rebase` 的节点做 `git diff`），将所有做过改动的文件名记录（保存为 `tmp/diff-分支名.txt`）
2. 所有有 diff 的分支之间两两做比较，下述步骤都是说的每两个分支之间的操作：
3. 通过 `git merge-base`，找到两个分支的最近公共节点
4. 通过 `git merge-tree` 做公共节点和两个分支的三方合并比对
5. 在比对结果中，过滤掉第一步中没有记录的文件（因为很可能是 `master` 分支不同 commit 之间的差异）
6. 如果代码全部为增或全部为减，则不认为冲突，同时有增减的情况才判定为冲突（在标记差异的 `=====` 的上下两侧都有代码变化）

如这段认为是没有冲突

    +<<<<<<< .our
    +=======
    +  m_AnchoredPosition: {x: 0, y: -0.000019550323}
    +  m_SizeDelta: {x: 308, y: 138}
    +>>>>>>> .their


而这是有冲突（在提示冲突的结尾会显示为 `文件名:2+2`）

    +<<<<<<< .our
       m_AnchoredPosition: {x: 0, y: 0}
       m_SizeDelta: {x: 445, y: 138}
    +=======
    +  m_AnchoredPosition: {x: 0, y: -0.000019550323}
    +  m_SizeDelta: {x: 308, y: 138}
    +>>>>>>> .their
